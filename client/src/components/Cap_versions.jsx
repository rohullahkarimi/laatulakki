/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.4 public/models/cap_version_0.gltf
*/
import React, { useEffect, useState } from "react";
import {
  useGLTF,
  Decal,
  Environment,
  RenderTexture,
  PerspectiveCamera,
} from "@react-three/drei";

import * as THREE from "three";
import { TextureLoader } from 'three';
import { useThree, extend, useLoader } from "@react-three/fiber";
import { gsap } from "gsap";
import { Text as Troika } from "troika-three-text";
import { useCustomization } from "../contexts/Customization";
import { ErrorBoundary } from "react-error-boundary";

// Register Text as a react-three-fiber element
extend({ Troika });

const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const dimension = isIOS ? 700 : 1500;

// Define an error boundary component
function MyErrorBoundary({ error, componentStack }) {
  // You can customize the error message and display
  // based on the specific error that occurred
  return (
    <div>
      <h2>An error occurred in the Troika Text component:</h2>
      <pre>{error.message}</pre>
      <pre>{componentStack}</pre>
    </div>
  );
}

function Ylioppilaslakki(props) {
  const { camera } = useThree();
  const { nodes, materials } = useGLTF("/public/models/cap_version_14-transformed.glb");
  //const { nodes, materials } = useGLTF("/public/models/cap_version_14.gltf");
  
  const texture = new THREE.TextureLoader().load(
    "public/textures/embroidery/embroideryTexture.jpg"
  );
 

  const [isFromBack, setIsFromBack] = useState(false);
  texture.wrapS = THREE.RepeatWrapping;
  texture.wrapT = THREE.RepeatWrapping;
  texture.repeat.set(0.9, 0.33);
  texture.anisotropy = 16;

  const { customization } = useCustomization();
  const textFrontLeft = customization.embroidery.embroideryTextFront.left;
  const textFrontRight = customization.embroidery.embroideryTextFront.right;
  const textBack = customization.embroidery.embroideryTextBack;
  const color = customization.embroidery.embroideryTextColor;
  const fontName = customization.embroidery.embroideryFont;
  const focus = customization.focus;
  let font = "";
  if (fontName === "kauno") {
    font = "/public/Fonts/snellk.woff";
  } else {
    font = "/public/Fonts/arial.woff";
  }

  //console.log(color, focus)

  useEffect(() => {
    try {
      if (focus === "back") {
        gsap.to(camera.rotation, {
          y: 3.14,
          onStart: () => {
            gsap.fromTo(
              camera.position,
              { y: 1.5 },
              {
                z: -2,
                x: 0,
                y: 0,
                duration: 2,
              }
            );
          },
          duration: 2,
        });
        setIsFromBack(true);
      } else if (focus === "frontRight") {
        gsap.to(camera.rotation, {
          y: 0,
          onStart: () => {
            gsap.fromTo(
              camera.position,
              { y: isFromBack ? 1.2 : 0 },
              {
                z: 2,
                x: 1,
                y: 0,
                duration: 2,
              }
            );
          },
          duration: 2,
        });

        setIsFromBack(false);
      } else {
        gsap.to(camera.rotation, {
          y: 0,
          onStart: () => {
            gsap.fromTo(
              camera.position,
              { y: isFromBack ? 1.2 : 0 },
              {
                z: 2,
                x: -1,
                y: 0,
                duration: 2,
              }
            );
          },

          duration: 2,
        });
        setIsFromBack(false);
      }
    } catch (error) {
      console.error("An error occurred in the useEffect:", error);
      // Handle the error, e.g., show an error message or fallback behavior
    }
  }, [focus]);



  //console.log(customization)

  // color less velvet texture
  const velvetTexture = new TextureLoader().load('/public/textures/velvet/velvet_texture.png');
  velvetTexture.wrapS = THREE.RepeatWrapping; // Repeat the texture horizontally
  velvetTexture.repeat.set(3, 1); // Adjust the repeat to fit the ribbon length


  // Define the materials
  const ribbonMaterials = {
    black: createCustomMaterial(velvetTexture, 0x000000), // Black default material
    gold: materials.gliter_texture_gold,
    silver: materials['gliter_texture_.001'],
    rose_gold: createCustomMaterial(velvetTexture, 0xFFC0CB), // Apply color using custom material
    dark_blue: createCustomMaterial(velvetTexture, 0x012483), // Apply color using custom material
    yellow: createCustomMaterial(velvetTexture, 0xFEEF01),
    light_blue: createCustomMaterial(velvetTexture, 0xBBDEF0), // Apply color using custom material
  };

  // Function to create custom material
 // Function to create custom material with darkness effect and opacity
function createCustomMaterial(texture, color, darknessFactor = 0.02, opacity = 0.9) {
  const material = new THREE.MeshStandardMaterial({ map: texture });
  material.onBeforeCompile = shader => {
    shader.uniforms.customColor = { value: new THREE.Color(color) };
    shader.uniforms.darknessFactor = { value: darknessFactor };
    shader.fragmentShader = `
      uniform vec3 customColor;
      uniform float darknessFactor;
      ${shader.fragmentShader.replace(
        '#include <map_fragment>',
        `
          #include <map_fragment>
          diffuseColor.rgb *= customColor;
          diffuseColor.rgb -= vec3(darknessFactor); // Add darkness effect
        `
      )}
    `;
  };
  material.opacity = opacity;
  material.transparent = true; // Enable transparency
  return material;
}



 
  let chosenMaterial;

 
  chosenMaterial = ribbonMaterials[customization.roundRibbonColor];
 

  return (
    <group {...props} dispose={null}>
   
      {/* decorative ribbon based on user chosen */}
      <mesh
      geometry={nodes.roundRibbonribon_gliter_gold.geometry}
      material={chosenMaterial}
      visible={customization.roundRibbonColor ? true : false}
      />
      {
      /*
      <mesh geometry={nodes.roundRibbonribon_gliter_gold.geometry} material={materials.gliter_texture_gold} />
      <mesh geometry={nodes.roundRibbonribon_gliter_silver.geometry} material={materials['gliter_texture_.001']} />
      <mesh geometry={nodes.roundRibbonribon_velvet_GOLD.geometry} material={materials.velvet_texture_GOLD} />
      <mesh geometry={nodes.roundRibbonribon_velvet_silver.geometry} material={materials.velvet_texture_} />
        */
      }

      {/* Cord */}
      <mesh geometry={nodes.cordblack.geometry} material={materials['line 1.002']} visible={customization.cordColor === "black"}/>
      <mesh geometry={nodes.cordgold.geometry} material={materials['Tape. gliter gold']} visible={customization.cordColor === "gold"} />
      <mesh geometry={nodes.cordsilver.geometry} material={materials['line 1.001']} visible={customization.cordColor === "silver"}/>

      
      
      
      {/* badge */}
      <mesh geometry={nodes.badgeclassic.geometry} material={materials['Material.005']}   visible={customization.badge === "fi"}/>
    
      <mesh geometry={nodes.badgestarcube.geometry} material={materials['diamond.001']} visible={customization.badge === "star"}/>
      <mesh geometry={nodes.badgestarcube_1.geometry} material={materials.gold} visible={customization.badge === "star"}/>

      <mesh geometry={nodes.badgecrystalcube.geometry} material={materials.gold} visible={customization.badge === "crystal"}/>
      <mesh geometry={nodes.badgecrystalcube_1.geometry} material={materials['diamond.001']} visible={customization.badge === "crystal"}/>
     

      {/* embroidery */}
      <mesh geometry={nodes.embroideryTextleft.geometry} material={materials['Material.002']}  visible={false}/>
      <mesh geometry={nodes.embroideryTextright.geometry} material={materials['Material.002']} visible={false}/>
      <mesh geometry={nodes.embroideryTextback.geometry} material={materials['Material.002']} visible={false}/>

      <ErrorBoundary FallbackComponent={MyErrorBoundary}>
        <mesh geometry={nodes.pantavelvetBlack.geometry} material={materials['outside black']} >
        <Decal
            position={[-0.19099999999999948, 0.36, 0.640000000000005]}
            rotation={[0, 0, -3.14]}
            scale={1.8}
          >
            <meshPhysicalMaterial
              roughness={0.9}
              transparent
              polygonOffset
              polygonOffsetFactor={-1}
              position={[0, 0, 1]}
            >
              <RenderTexture width={dimension} height={dimension} attach='map'>
                <PerspectiveCamera
                  makeDefault
                  manual
                  position={[0, 0, 400]}
                  rotation={[0, 0, -3.14]}
                />
                <ambientLight intensity={1} />

                <directionalLight intensity={1} position={[0, 0, 1]} />
                <pointLight position={[0, 0, 1]} />
                <Environment preset='city' />
                <troika
                  rotation={[0, 0, 0.07]}
                  text={textFrontLeft}
                  fontSize={15}
                  size={1}
                  color={color}
                  depthOffset={5}
                  anchorX='right'
                  font={font}
                  position={[15, 11, 0]}
                >
                  <meshStandardMaterial
                    roughness={1}
                    metalness={0.1}
                    attach='material'
                    map={texture}
                  />
                  
                </troika>
                <troika
                  rotation={[0, 0, -0.06]}
                  text={textFrontRight}
                  fontSize={15}
                  size={1}
                  color={color}
                  depthOffset={5}
                  anchor='center'
                  font={font}
                  position={[66.39999999999979, 11, 0]}
                >
                  <meshStandardMaterial
                    roughness={1}
                    metalness={0.1}
                    attach='material'
                    map={texture}
                  />
                </troika>
              </RenderTexture>
            </meshPhysicalMaterial>
          </Decal>

          <Decal
            position={[-0.391, 0.36, -0.46]}
            rotation={[0, -3.14, -3.14]}
            scale={1.8}
          >
            <meshPhysicalMaterial
              roughness={0.9}
              transparent
              polygonOffset
              polygonOffsetFactor={-1}
              position={[0, 0, 1]}
            >
              <RenderTexture width={dimension} height={dimension} attach='map'>
                <PerspectiveCamera
                  makeDefault
                  manual
                  position={[0, 0, 400]}
                  rotation={[0, 0, -3.14]}
                />
                <ambientLight intensity={1} />

                <directionalLight intensity={1} position={[0, 0, 1]} />
                <pointLight position={[0, 0, 1]} />
                <Environment preset='city' />
                <troika
                  rotation={[0, 0, 0]}
                  text={textBack}
                  fontSize={15}
                  size={1}
                  color={color}
                  depthOffset={5}
                  anchorX='center'
                  font={font}
                  position={[-76.7, -35, 0]}
                >
                  <meshStandardMaterial
                    roughness={0.01}
                    attach='material'
                    metalness={0.01}
                    map={texture}
                  />
                </troika>
              </RenderTexture>
            </meshPhysicalMaterial>
          </Decal>
        </mesh>
      </ErrorBoundary>




     

      {/* Extra stuff */}
      <mesh geometry={nodes.visorfrontLine.geometry} material={materials['line 2']} />
      <mesh geometry={nodes.rusetti.geometry} material={materials.sloejfe_m} />
      <mesh geometry={nodes.visor.geometry} material={materials['outide black 1']} />
      <mesh geometry={nodes.panta.geometry} material={materials['inside leather']} />
      <mesh geometry={nodes.pantabottom.geometry} material={materials['inside black']} />

      



      <mesh geometry={nodes.blueWhite.geometry} material={materials['inside white 1']} />
      <mesh geometry={nodes.whiteVelvet.geometry} material={materials['outside white']} />
      <mesh geometry={nodes.insidewhite.geometry} material={materials['inside white with fold']} />

    </group>
  );
}

export default Ylioppilaslakki;

//useGLTF.preload("/public/models/cap_version_9.gltf");
